#!/usr/bin/python

from trout.conf.config import *
from trout.utils.graphics import *
from trout.utils.misc import *
from trout.shared.constants import * 
import sklearn, numpy, json
import os

def extractCountFeatures(allSequences, includeTriggers=True):
    """
    Extracts simple numerical features depicting the occurrence counts for every unique (trigger, payload) tuple in a sequence
    :param allSequences: The sequences of all apps
    :type allSequences: list
    :param ignoreTriggers: Whether to include trigger categories as part of the features (default: True)
    :type ignoreTriggers: bool
    :return: A list of lists depicting the feature vectors extracted from every sequence
    :return: An ordered list of (trigger, payload) tuples extracted from sequences i.e. features
    """
    try:
        allTokens = []
        featureVectors = []
        # 1. Retrieve all possible (trigger, payload) tuples to estimate vector size
        ignore = "False" if not includeTriggers else "True"
        prettyPrint("Retrieving (trigger, payload) tuples from sequences. Ignoring triggers set to \"%s\"" % ignore)
        for sequence in allSequences:
            for t in sequence:
                token = t if includeTriggers else t[1]
                if not token in allTokens:
                    prettyPrint("Adding the tuple %s to list" % str(token))
                    allTokens.append(token)
        prettyPrint("Successfully retrieved %s tokens from %s sequences" % (len(allTokens), len(allSequences)))
        # 2. Extract counts of tokens from sequences
        for sequence in allSequences:
            vector = []
            for feature in allTokens:
                vector.append(float(sequence.count(feature)))
            featureVectors.append(vector)
    except Exception as e:
        prettyPrintError(e)
        return [], []

    return featureVectors, allTokens

def extractDroidmonFeatures(logPath, mode="classes", includeArguments=False):
    """
    Extracts numerical features from Droidmon-generated logs
    :param logPath: The path to the JSON-log generated by Droidmon
    :type logPath: str
    :param mode: The type of features to extract (i.e. classes, methods, both)
    :type mode: str
    :param includeArguments: Whether to include the method argument in the trace
    :type includeArguments: bool
    :return: Two lists depicting the trace found in the log and counts of items it contains
    """
    try:
        features = []
        # Parse the droidmon log
        if not os.path.exists(logPath):
            prettyPrint("Unable to locate \"%s\"" % logPath, "warning")
            return [], []
        lines = open(logPath).read().split('\n')
        if VERBOSE == "ON":
            prettyPrint("Successfully retrieved %s lines from log" % len(lines), "debug")
        droidmonLines = [l for l in lines if l.lower().find("droidmon-apimonitor-") != -1]
        # Generate trace from lines
        trace = []
        for line in droidmonLines:
            tmp = line[line.find("{"):].replace('\n','').replace('\r','')
            # Extract class and method
            c, m = "", ""
            pattern = "class\":\""
            index = tmp.find(pattern)
            c = tmp[index+len(pattern):tmp.find("\"", index+len(pattern))]
            pattern = "method\":\""
            index = tmp.find(pattern)
            m = tmp[index+len(pattern):tmp.find("\"", index+len(pattern))]
            if includeArguments:
                pattern = "args\":["
                index = tmp.find(pattern)
                a = tmp[index+len(pattern):tmp.find(']', index+len(pattern))]
            # Prepare to add args
            args = "" if not includeArguments else a
            # Append to trace
            if mode == "classes":
                trace.append("%s(%s)" % (c, args))
            elif mode == "methods":
                trace.append("%s(%s)" % (m, args))
            elif mode == "both":
                trace.append("%s.%s(%s)" % (c, m, args))
        # Go over droidmon classes and count occurrences
        source = []
        if mode == "classes":
            source = droidmonDefaultClasses
        elif mode == "methods":
            source = droidmonDefaultMethods
        elif mode == "both":
            source = droidmonDefaultAPIs

        # The loop
        noArgsTrace = [t[:t.find('(')] for t in trace]
        for i in source:
            features.append(noArgsTrace.count(i))

    except Exception as e:
        prettyPrintError(e)
        return [], []

    return trace, features

def extractStaticFeatures(source):
    """
    Extracts general static features from app representations
    :param source: The source of the app's representation (e.g., file or dict)
    :type source: str or dict
    :return: A list of str depicting the description of individual features in the vector 
    :return: A list of float depicting the numerical features of the app
    """
    try:
        attributes, features = [], []
        # 1. Check source type
        data = json.loads(open(source).read()) if type(source) == str else source
        if len(data) < 1:
            prettyPrint("Unable to retrieve any content from file", "error")
            return [], []
        # 2. Extract features
        # 2.a. APK size
        attributes.append("size") # APK Size
        features.append(data["size"])
        # 2.b. Permissions
        attributes.append("total_permissions") # No. total permissions
        features.append(len(data["permissions"]))
        attributes.append("android_permissions") # No. Android permissions
        androidPerms = [p for p in data["permissions"] if p in androidPermissions]
        features.append(len(androidPerms))
        attributes.append("ratio_android_permissions") # Android permissions : total permissions
        if len(data["permissions"]) == 0:
            features.append(0.0)
        else:
            features.append(float(len(androidPerms))/float(len(data["permissions"])))
        attributes.append("custom_permissions") # No. of custom permissions
        features.append(len(data["permissions"])-len(androidPerms))
        attributes.append("ratio_custom_permissions")
        if len(data["permissions"]) == 0:
            features.append(0.0)
        else:
            features.append(float(len(data["permissions"])-len(androidPerms))/float(len(data["permissions"])))
        for p in androidPermissions:
            permission = p.replace("android.permission.", "")
            attributes.append("has_%s" % permission)
            has_permission = 1 if p in data["permissions"] else 0
            features.append(has_permission)
        # 3. Counts of categories of API calls in an app data["global_sensitive_categories"]
        attributes.append("total_sensitive_categories") # No. of categories ("network", "crypto", "sms", etc.)
        features.append(sum(data["global_sensitive_categories"].values()))
        for c in staticCategories:
            attributes.append("count_%s" % c)
            count = 0 if not c in data["global_sensitive_categories"] else data["global_sensitive_categories"][c]
            features.append(count)
        # 4. Breakdown of categories above as aPI calls data["global_sensitive_apis"]
        for p in staticPackages:
            attributes.append(p)
            count = 0
            for entry in data["global_sensitive_apis"]:
                if entry.lower().find(p.lower()) != -1:
                    count += 1
            features.append(count)
        # 5. Number of suspicious methods data["num_suspicious_methods"]
        attributes.append("suspicious_methods")
        features.append(data["num_suspicious_methods"])

    except Exception as e:
        prettyPrintError(e)
        return [], []

    return attributes, features

















